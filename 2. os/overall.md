## 운영체제 입문

## 운영체제란 :: 
컴퓨터의 goverment와 같다. 
정부 그 자체만으로는 쓸모있는 기능을 하지 못하나, 사람들과 프로그램에게 더 나은 환경을 제공한다.

컴퓨터의 하드웨어를 관리하고, 하드웨어와 소프트웨어, 사용자를 매개한다. 

따라서, 운영체제의 역할은 사용자 관점과 시스템 관점으로 나눠볼 수 있다.

사용자에게는 편리한 환경 제공, 시스템에게는 자원 할당자로서의 역할

1. 부팅
-> 전원을 누르면, 커널이라는 운영체제의 일부가 메모리에 올라와 실행됨
-> 장치 준비, 레지스터 값 초기화하고 등등의 준비를 마치면 부팅됐다고 함.

-> 부트 프로그램이나 부츠트랩로더라는, rom에 저장돼있는 작은 프로그램들이 커널을 찾아 메모리에 올려준다.
- 보통은, rom에 부츠트랩로더가 디스크에 있는 부트프로그램을 메모리에 올려 실행시키고, 이 부트 프로그램이 커널을 올려 실행시킨다.
---

2. 레지스터 
메모리보다 빠른 기억장치. 
그러나 크기가 작아서, 8/16/32비트 크기이다. 
---

3. 명령어 처리
명령어를 읽어서 처리기에 있는 레지스터로 갖고 와야한다. 
연산을 제어하기 위해 레지스터들이 동원되고, 이를 fetch라 한다.
---

4. 인터럽트
이벤트 발생을 알리는 것을 인터럽트(Interrupt)라고 부른다. 
인터럽트는 '방해하다’라는 뜻인데, 컴퓨터에서는 신호를 보내 이벤트 발생을 알리는 것을 의미한다. 
보통 컴퓨터는 여러 작업을 동시에 처리하는데, 이때 당장 처리해야 하는 일이 생겨서 기존의 작업을 잠시 중단해야 하는 경우 인터럽트 신호를 보낸다. 
그러면 커널은 작업을 멈추고 인터럽트를 처리한 뒤 다시 기존 작업으로 돌아온다.

현대 운영체제들은 대부분 인터럽트 주도적(Interrupt driven)이다. 
인터럽트가 발생하기 전까지 CPU는 대기상태에 머문다. 
반면 폴링(Polling)의 경우 주기적으로 이벤트를 감시해 처리 루틴을 실행한다. 
이렇게 하면 컴퓨팅 자원을 낭비하게 되기 때문에 인터럽트 주도적으로 설계하는 것이다.

운영체제의 임무 : 자원을 효과적으로 관리하는 것. 
그 첫 단계로 각 자원의 상황을 알아야한다.

cpu가 직접 나서서 자원들 상태를 확인하는 것을 폴링이라고 한다면,
인터럽트는 각 자원들이 저요저요 하고 자신의 상태변화를 알린다. 따라서 대부분의 시스템에서 이를 채택중이다.

 * 트랩? cpu스스로 자신에게 인터럽트를 해야하는 경우. 소프트웨어 인터럽트라 불린다. (실행중인 명령어때문에 생기는 일이므로)

- 어떻게 인터럽트 처리를 하게될까? 
장치가 인터럽트 신호를 cpu에 보내고, cpu는 일단 진행중이었던 명령어 실행을 완료시킨 뒤, 인터럽트 신호를 확인한다.
인터럽트 처리하기 전에, 실행중이던 프로그램의 정보를 시스템 스택에 저장한다. psw, pc레지스터의 값들을 ! 

인터럽트 처리는 일단 cpu에 있는 레지스터들의 값을 저장후, 처리한다. 

- 중첩된 인터럽트의 처리? 
순차 처리하거나, 말그대로 중첩 처리하거나!

- 인터럽트 처리 과정
보통 컴퓨터는 여러 작업을 동시에 처리하는데, 만약 CPU가 인터럽트 신호를 받으면, 
하던 일을 잠시 멈추고 메모리의 어떤 고정된 위치(Fixed location)를 찾는다. 
이 위치는 인터럽트 벡터(Interrupt vector)에 저장되어 있다. 
인터럽트 벡터는 인터럽트를 처리할 수 있는 서비스 루틴(Service routine)들의 주소를 가지고 있는 공간으로, 파일 읽기/쓰기와 같은 중요한 동작들이 하드코딩되어 있다. 
이렇게 인터럽트를 처리하고나면 CPU는 다시 원래 작업으로 돌아온다. 
이 과정은 사용자가 눈치채지 못할 정도로 매우 빠르게 일어날 수도 있고, 너무 느려서 오랜 시간을 기다려야 할 수도 있다. 
참고로 어떤 값을 0으로 나누는 것(Division by zero)도 인터럽트이며, 이러한 내부 인터럽트(Internal interrupt)는 예외(Exception)라고 부른다.
---

5. 기억장치의 계층적 구조
프로그램이 cpu에 의해 실행되는데, 기억장치 내부에서 상위에 있을수록 시스템의 성능은 좋아진다(ex 레지스터)
커널은 실행기(Executor)를 통해 프로그램을 실행시킨다. 
실행기는 기억장치(Storage)에서 exe파일(Windows의 경우)을 가져오고, 커널이 이것을 메모리에 할당해 실행시킨다. 
이처럼 모든 프로그램은 메인 메모리에 로드되어 실행되며, 메인 메모리는 보통 RAM(Random-Access Memory)이라고 부른다. 하지만 RAM은 모든 프로그램을 담기엔 너무 작고 비싸다. 

또한 전원이 나가면 저장된 데이터가 모두 사라지는 휘발성(Volatile) 장치다. 그래서 보조기억장치(Secondary storage)가 필요하다. 
자기테이프(Magnetic tapes), 광학디스크(Optical disk), 자기디스크(Magnetic disk), SSD(Soli-State Disk)는 비휘발성(Non-volatile) 기억장치다. 
반면 메인 메모리, 캐시(Cache), 레지스터(Registers)는 휘발성 기억장치다. 보조기억장치는 용량이 크고 저렴한 반면, 캐시나 레지스터는 용량이 작고 비싸다.

요즘 컴퓨터에는 최대절전 모드가 있다. 
컴퓨터가 절전모드에 들어가면 메모리의 모든 데이터를 덤프해서 보조기억장치에 담아두고, 다시 절전모드를 빠져나오면 덤프해둔 데이터를 불러와 그대로 작업을 수행한다. 
영어로는 하이버네이트(Hibernate)라고 한다.

Direct Memory Access Structure
과거에는 장치 데이터를 처리하기 위해 CPU를 거쳐 메모리에 로드하는 방식을 사용했으나, CPU 자원이 너무 많이 소모되기 때문에 이젠 DMA(Direct Memory Access)를 사용한다. 
DMA는 장치와 메모리를 직접 연결하는 방식으로, 버스가 지원하는 기능이다. 
메모리의 일정 부분은 DMA에 사용될 영역으로 지정되며, DMA를 제어하는 컨트롤러는 DMA 컨트롤러라고 부른다. 참고로 CPU를 거치는 방식은 PIO(Programmed I/O)라고 부른다. 
장치의 데이터는 장치 컨트롤러에 의해 직접 메모리에 전달되며, CPU에서는 데이터 이동이 완료되었다는 인터럽트만 한 번 일어난다. 이렇게 하면 결과적으로 CPU가 하는 일이 줄어드니까 성능이 좋아진다.

6. i/o 방식
입출력 장치에는 컨트롤러, 그 안에는 cpu와 데이터를 저장하는 버퍼가있다. 
cpu는 버퍼의 내용을 메모리로 옮긴 뒤 다음 입력을 지시한다. 

방식은 세가지.
- 프로그램에 의한 입출력?
계속 컨트롤러의 버퍼에 입력됐는지를 cpu가 확인한다. 따로 인터럽트를 할 필요가 없으나 cpu가 지속적으로 완료의 여부를 확인해야한다.
이 경우 cpu는 작업 완료까지 다른 작업을 할 수 없어 낭비된다. 

- 인터럽트에 의한 입출력? 
인터럽트를 통해 cpu에 알려진다.

- 메모리에 직접 접근하는 입출력
인터럽트에 의한 입출력의 단점은 버퍼의 크기에 의존적이라는 것인데, 이 횟수를 줄이고자하는 것이 dma이다. dma를 위해서는 입출력 작업을 cpu 대신 해줄 수 있는 채널이라는 위성 프로세서가 필요하다. 이 채널에 cpu는 업무를 맡기고, 채널은 블록이라는 시스템 상 한번의 입출력 단위로 cpu에 보낸다. 

- 독립적인 입출력
입출력 장치들이 입출력 버스를 통해 cpu와 연결돼있다. (메모리는 따로 메모리버스를 통해 연결돼있다.)

- 메모리 주소지정 입출력
입출력 장치들이 메모리와 함께 메모리버스에 연결.
---

7. 컴퓨터 구조

```
               disks     mouse, keyborad, printer     monitor
                 |                   |                   |
+-----+ +--------+--------+ +--------+-------+ +---------+--------+
| CPU | | disk controller | | USB controller | | graphics adapter |
+--+--+ +--------+--------+ +--------+-------+ +---------+--------+
   |             |                   |                   |
   +-------------+---------+---------+-------------------+
                           |
                       +---+----+
                       | memory |
                       +--------+
```

현대의 일반적인 컴퓨터 시스템은 여러개의 CPU와 장치 컨트롤러(Device controllers)로 구성되어 있다. 그리고 이들은 공통버스(Commmon bus)로 이어져 메모리를 공유한다.
* Single-Processor Systems
과거 대부분의 컴퓨터는 싱글 프로세서를 사용했다. 
싱글 프로세서 컴퓨터에는 하나의 메인 CPU만 탑재되며, 장치에 따라 특별한 목적을 가진 프로세서가 들어갔다. 
디스크 프로세서는 디스크 연산만 수행하고, 키보드 프로세서는 키보드 연산만 수행하는 식.

* Multiprocessor Systems
이젠 일반적인 컴퓨터 시스템. 멀티 프로세서 컴퓨터는 2개 이상의 프로세서를 가지고 있다. 
처음에는 서버 컴퓨터에 처음 적용됐는데, 지금은 모바일 기기도 멀티 프로세서 시스템으로 만들어진다. 멀티 프로세서 시스템은 몇가지 장점을 가지고 있다.

처리량(Throughput)의 증가: 프로세서가 늘어나면 더 빠른 시간 안에 연산을 수행할 수 있다. 
물론 프로세서를 계속 늘린다고 성능이 한없이 좋아지는 것은 아니며, 증가 비율이 1:1인 것도 아니다.


규모의 경제: 멀티 프로세서 시스템은 여러 대의 싱글 프로세서 시스템을 구축하는 것보다 돈이 적게 든다. 멀티 프로세서 시스템은 주변장치(Peripherals)를 공유할 수 있기 때문이다.


신뢰성의 증가: 만약 기능이 여러 프로세서에 분산될 수 있다면, 하나의 프로세서가 작동을 멈춰도 전체 시스템은 느려질 뿐 멈추지 않는다. 이런 식으로 성능이 나빠지지만 작동은 가능하도록 하는 것을 우아한 성능저하(Graceful degradation)라고 부른다. 그리고 이렇게 성능을 저하함으로써 작업을 계속 유지하는 시스템을 장애 허용 시스템(Fault tolerant)이라고 부른다.


* 멀티 프로세서 컴퓨터는 2개 이상의 프로세서를 가지고 있다. 
멀티 프로세서 시스템은 비대칭 멀티프로세싱(Asymmetric multiprocessing)과 대칭 멀티프로세싱(Symmetric multiprocessing) 두 가지로 나뉜다. 
비대칭 멀티프로세싱은 대기업!  보스 프로세서(Boss processor)가 시스템을 제어하고, 다른 프로세서들은 보스의 지시를 받게 된다. 
이렇게 하면 부하 분산(Load balancing)을 효율적으로 할 수 있다. 대신 보스 프로세서가 작동을 멈추면 일꾼 프로세서들도 멈추게 된다. 
대칭 멀티프로세싱은 보스가 없는 자유로운 회사다. 모든 프로세서들은 하나의 메모리를 공유하고, 동일한 작업을 병렬적으로 수행한다. 만약 프로세서에 이상이 생겨 작동을 멈춰야 한다면 자신이 수행하던 작업을 다른 프로세서들에게 나눠주고 자신만 재부팅한다. 재부팅 후 문제가 해결된다면 다시 작업을 나눠 받는다. 비대칭 멀티프로세싱 시스템의 단점을 보완할 수 있는 아키텍처이기 때문에 대부분의 컴퓨터 시스템은 대칭 멀티프로세싱을 사용한다.

멀티 프로세서 시스템의 CPU들은 각자의 레지스터와 캐시를 갖고 있다. 
만약 CPU가 여러 개라면 돌아가면서 작업을 해야 하는데, 그러면 다른 CPU가 작업을 하는 동안 다른 CPU들은 놀게 된다.

* A Dual-Core Design
CPU가 늘어나면 프로세서간 통신을 하는 데 많은 비용이 들기 때문에 효율이 계속 좋아지지는 않는다. 
조별 과제를 생각해보자. 내 아이큐 150, 네 아이큐 150을 합치면 총 300이지만, 머리가 많다고 좋은 것은 아니듯이!
사람이 늘어날수록 커뮤니케이션의 어려움은 커진다.

최근 CPU 설계 트렌드는 하나의 칩(Chip)에 코어(Cores)를 늘리는 것이다. 이러한 멀티 프로세서 시스템을 멀티코어(Multicore)라고 부른다. 코어는 동일한 성능의 CPU 여러 개를 1개의 칩 속에 집접한 것이라고 보면 된다. 칩 내부의 통신(On-chip communication)이 칩 사이의 통신(Between-chip communication)보다 더 빠르기 때문에 여러 개의 칩에 하나의 코어만 두는 시스템보다 더 효율적이다. 뿐만 아니라 하나의 칩에 여러 코어를 담으면 전력을 더 적게 사용한다.

각 코어는 자신만의 레지스터와 로컬 캐시를 갖는다. (하나의 캐시를 공유하기도 한다.)

* Clustered Systems
멀티프로세서 시스템의 일종인 클러스터 시스템(Clustered system)은 여러개의 CPU을 모아 놓은 구조다. 클러스터 시스템은 여러개의 개별 시스템(또는 노드)들이 하나로 모여있다는 점에서 앞서 설명한 멀티프로세서 시스템과는 조금 다르다. 멀티프로세서 시스템은 여러CPU가 하나의 시스템을 이루는 것이지만, 클러스터 시스템은 여러 독립적인 시스템이 모여 하나의 시스템을 이루는 것이다. 이런 시스템을 약결합(Loosely coupled)라고 부르며, 각 노드들은 싱글 프로세서 시스템일수도 있고, 멀티코어 시스템일 수도 있다.

클러스터의 정의가 딱 명확히 정해져 있지는 않다. 단지 클러스터 컴퓨터들이 하나의 저장소를 공유하고, 이를 LAN(Local-Area Network)과 같은 네트워크로 연결한 시스템을 보통 클러스터 시스템이라고 부른다. 클러스터링은 고가용성(High-availability) 서비스를 제공하기 위해 사용되며, 단일 컴퓨터보다 훨씬 저렴하게 비슷한 성능을 낼 수 있다.

클러스터 시스템은 비대칭 클러스터링(Asymmetric clustering)과 대칭 클러스터링(Symmetric clustering)으로 나뉜다. 비대칭 클러스터링에서 하나의 장비는 상시 대기 모드(Hot-standby mode)로 작동하며, 서버를 동작시키고 있는 다른 노드들을 모니터링할 뿐 별도의 작업은 수행하지 않는다. 만약 서버에 문제가 생기면 이 상시 대기 노드가 서버로서 작동하게 된다. 대칭 클러스터링은 두개 이상의 노드가 작업을 수행하는 동시에 다른 노드들을 모니터링하는 구조다. 이러한 구조는 하드웨어의 자원을 최대로 사용할 수 있어 더 효율적이다.

클러스터 시스템은 여러개의 컴퓨터 시스템이 네트워크로 연결되어 있는 구조이기 때문에 고성능 컴퓨팅 환경(High-performance computing environments)을 제공할 수 있다. 다만 단일 시스템에 비해 유지보수가 힘들고, 시스템의 성능이 네트워크 환경에 많은 영향을 받는다는 단점이 있다